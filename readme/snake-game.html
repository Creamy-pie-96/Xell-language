<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NEON SERPENT</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');

  :root {
    --neon-green: #00ff88;
    --neon-pink: #ff00aa;
    --neon-blue: #00ccff;
    --neon-yellow: #ffee00;
    --bg: #050510;
    --grid: #0a0a1f;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    font-family: 'Share Tech Mono', monospace;
    overflow: hidden;
    cursor: none;
  }

  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background: 
      repeating-linear-gradient(0deg, transparent, transparent 39px, rgba(0,255,136,0.03) 40px),
      repeating-linear-gradient(90deg, transparent, transparent 39px, rgba(0,255,136,0.03) 40px);
    pointer-events: none;
    z-index: 0;
  }

  body::after {
    content: '';
    position: fixed;
    inset: 0;
    background: radial-gradient(ellipse at 50% 50%, rgba(0,50,30,0.3) 0%, transparent 70%);
    pointer-events: none;
    z-index: 0;
  }

  #wrapper {
    position: relative;
    z-index: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
  }

  h1 {
    font-family: 'Orbitron', monospace;
    font-weight: 900;
    font-size: 2.8rem;
    color: var(--neon-green);
    text-shadow: 0 0 10px var(--neon-green), 0 0 30px var(--neon-green), 0 0 60px rgba(0,255,136,0.4);
    letter-spacing: 0.2em;
    animation: flicker 4s infinite;
  }

  @keyframes flicker {
    0%,95%,97%,100% { opacity: 1; }
    96% { opacity: 0.7; }
    98% { opacity: 0.9; }
  }

  #hud {
    display: flex;
    gap: 48px;
    font-size: 0.85rem;
    letter-spacing: 0.15em;
    color: rgba(0,255,136,0.6);
  }

  #hud span { display: flex; flex-direction: column; align-items: center; gap: 2px; }
  #hud strong { font-family: 'Orbitron', monospace; font-size: 1.4rem; color: var(--neon-green); text-shadow: 0 0 8px var(--neon-green); }

  #canvas-wrap {
    position: relative;
  }

  canvas {
    display: block;
    border: 1px solid rgba(0,255,136,0.3);
    box-shadow: 
      0 0 0 1px rgba(0,255,136,0.1),
      0 0 20px rgba(0,255,136,0.15),
      0 0 60px rgba(0,255,136,0.08),
      inset 0 0 30px rgba(0,0,20,0.9);
    image-rendering: pixelated;
  }

  #overlay {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 20px;
    background: rgba(5,5,16,0.88);
    backdrop-filter: blur(2px);
  }

  #overlay h2 {
    font-family: 'Orbitron', monospace;
    font-size: 2rem;
    font-weight: 700;
    letter-spacing: 0.15em;
  }

  #overlay p {
    color: rgba(0,255,136,0.6);
    letter-spacing: 0.1em;
    font-size: 0.85rem;
    text-align: center;
    line-height: 1.8;
  }

  .btn {
    font-family: 'Orbitron', monospace;
    font-size: 0.9rem;
    font-weight: 700;
    letter-spacing: 0.2em;
    color: var(--bg);
    background: var(--neon-green);
    border: none;
    padding: 12px 36px;
    cursor: pointer;
    clip-path: polygon(8px 0%, 100% 0%, calc(100% - 8px) 100%, 0% 100%);
    text-transform: uppercase;
    transition: all 0.15s;
    box-shadow: 0 0 20px rgba(0,255,136,0.5);
  }

  .btn:hover {
    background: #fff;
    box-shadow: 0 0 30px rgba(0,255,136,0.9), 0 0 60px rgba(0,255,136,0.4);
    transform: scale(1.04);
  }

  .dead-title { color: var(--neon-pink); text-shadow: 0 0 10px var(--neon-pink), 0 0 30px var(--neon-pink); }
  .start-title { color: var(--neon-green); text-shadow: 0 0 10px var(--neon-green), 0 0 30px var(--neon-green); }

  #level-badge {
    font-family: 'Orbitron', monospace;
    font-size: 0.7rem;
    color: var(--neon-blue);
    letter-spacing: 0.2em;
    text-shadow: 0 0 8px var(--neon-blue);
  }

  .controls-hint {
    font-size: 0.72rem;
    letter-spacing: 0.08em;
  }
</style>
</head>
<body>
<div id="wrapper">
  <h1>NEON SERPENT</h1>
  <div id="hud">
    <span><div>SCORE</div><strong id="score-display">0</strong></span>
    <span><div>LEVEL</div><strong id="level-display">1</strong></span>
    <span><div>BEST</div><strong id="best-display">0</strong></span>
  </div>
  <div id="canvas-wrap">
    <canvas id="c"></canvas>
    <div id="overlay">
      <h2 class="start-title">NEON SERPENT</h2>
      <p>Guide the serpent.<br>Consume the nodes.<br>Do not touch the walls or yourself.</p>
      <p class="controls-hint">ARROW KEYS or WASD to move</p>
      <button class="btn" id="start-btn">INITIALIZE</button>
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('start-btn');
const scoreEl = document.getElementById('score-display');
const levelEl = document.getElementById('level-display');
const bestEl = document.getElementById('best-display');

const CELL = 20;
const COLS = 25;
const ROWS = 25;
canvas.width = COLS * CELL;
canvas.height = ROWS * CELL;

let snake, dir, nextDir, food, specialFood, score, level, best, gameLoop, running, frameCount;
let particles = [];
let trail = [];

best = parseInt(localStorage.getItem('neonSnakeBest') || '0');
bestEl.textContent = best;

const COLORS = {
  head: '#00ff88',
  body: ['#00ff88','#00ee77','#00dd66'],
  food: '#ff00aa',
  special: '#ffee00',
  dead: '#ff0044',
};

function initGame() {
  snake = [{x:12, y:12},{x:11,y:12},{x:10,y:12}];
  dir = {x:1,y:0};
  nextDir = {x:1,y:0};
  score = 0;
  level = 1;
  frameCount = 0;
  particles = [];
  trail = [];
  specialFood = null;
  specialTimer = 0;
  placeFood();
  updateHUD();
}

function placeFood() {
  let pos;
  do {
    pos = {x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS)};
  } while (snake.some(s => s.x===pos.x && s.y===pos.y));
  food = pos;
}

let specialTimer = 0;

function getSpeed() {
  return Math.max(60, 150 - (level-1)*15);
}

function step() {
  frameCount++;
  if (frameCount % getSpeed() !== 0) { draw(); return; }

  dir = nextDir;
  const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

  // Wall collision
  if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) {
    die(); return;
  }
  // Self collision
  if (snake.some(s => s.x===head.x && s.y===head.y)) {
    die(); return;
  }

  trail.push({x: snake[snake.length-1].x, y: snake[snake.length-1].y, alpha: 0.6});

  snake.unshift(head);

  let ate = false;
  if (head.x===food.x && head.y===food.y) {
    score += 10 * level;
    spawnParticles(food.x, food.y, COLORS.food, 12);
    placeFood();
    ate = true;
    // Special food chance
    if (Math.random() < 0.25 && !specialFood) {
      placeSpecial();
      specialTimer = 180;
    }
    level = Math.floor(score / 100) + 1;
    updateHUD();
  }

  if (specialFood && head.x===specialFood.x && head.y===specialFood.y) {
    score += 50 * level;
    spawnParticles(specialFood.x, specialFood.y, COLORS.special, 20);
    specialFood = null;
    ate = true;
    updateHUD();
  }

  if (!ate) snake.pop();

  if (specialFood) {
    specialTimer--;
    if (specialTimer <= 0) specialFood = null;
  }

  draw();
}

function placeSpecial() {
  let pos;
  do {
    pos = {x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS)};
  } while (snake.some(s=>s.x===pos.x&&s.y===pos.y) || (food.x===pos.x&&food.y===pos.y));
  specialFood = pos;
}

function spawnParticles(gx, gy, color, count) {
  const cx = gx * CELL + CELL/2;
  const cy = gy * CELL + CELL/2;
  for (let i=0;i<count;i++) {
    const angle = (Math.PI*2/count)*i + Math.random()*0.3;
    const speed = 1.5 + Math.random()*2.5;
    particles.push({
      x:cx, y:cy,
      vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed,
      alpha:1, color, life:30+Math.random()*20, size: 2+Math.random()*3
    });
  }
}

function updateHUD() {
  scoreEl.textContent = score;
  levelEl.textContent = level;
  if (score > best) {
    best = score;
    localStorage.setItem('neonSnakeBest', best);
    bestEl.textContent = best;
  }
}

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Background
  ctx.fillStyle = '#050510';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // Subtle grid
  ctx.strokeStyle = 'rgba(0,255,136,0.04)';
  ctx.lineWidth = 0.5;
  for(let x=0;x<=COLS;x++){ctx.beginPath();ctx.moveTo(x*CELL,0);ctx.lineTo(x*CELL,canvas.height);ctx.stroke();}
  for(let y=0;y<=ROWS;y++){ctx.beginPath();ctx.moveTo(0,y*CELL);ctx.lineTo(canvas.width,y*CELL);ctx.stroke();}

  // Trail
  trail.forEach((t,i) => {
    ctx.fillStyle = `rgba(0,255,136,${t.alpha * 0.15})`;
    ctx.fillRect(t.x*CELL+4, t.y*CELL+4, CELL-8, CELL-8);
    t.alpha -= 0.08;
  });
  trail = trail.filter(t => t.alpha > 0);

  // Particles
  particles.forEach(p => {
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = p.color;
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 6;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
    ctx.fill();
    p.x += p.vx; p.y += p.vy;
    p.vx *= 0.92; p.vy *= 0.92;
    p.alpha -= 1/p.life;
  });
  particles = particles.filter(p => p.alpha > 0);
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;

  // Food
  drawFood();

  // Special food
  if (specialFood) {
    const pulse = 0.6 + 0.4*Math.sin(frameCount * 0.15);
    const cx = specialFood.x*CELL+CELL/2, cy = specialFood.y*CELL+CELL/2;
    ctx.shadowColor = COLORS.special;
    ctx.shadowBlur = 15 * pulse;
    ctx.fillStyle = COLORS.special;
    ctx.beginPath();
    // Star shape
    for(let i=0;i<5;i++){
      const r1=7, r2=3;
      const a1 = (Math.PI*2*i/5) - Math.PI/2;
      const a2 = (Math.PI*2*i/5 + Math.PI/5) - Math.PI/2;
      if(i===0) ctx.moveTo(cx+r1*Math.cos(a1), cy+r1*Math.sin(a1));
      else ctx.lineTo(cx+r1*Math.cos(a1), cy+r1*Math.sin(a1));
      ctx.lineTo(cx+r2*Math.cos(a2), cy+r2*Math.sin(a2));
    }
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // Snake
  snake.forEach((seg,i) => {
    const isHead = i===0;
    const t = i / snake.length;
    const greenVal = Math.floor(255 - t*80);
    const alpha = 1 - t*0.3;
    
    ctx.shadowColor = '#00ff88';
    ctx.shadowBlur = isHead ? 20 : 10 - t*8;
    ctx.fillStyle = isHead ? '#00ff88' : `rgba(0,${greenVal},${Math.floor(greenVal*0.5)},${alpha})`;
    
    const pad = isHead ? 1 : 2 + t*1;
    const r = 4;
    roundRect(ctx, seg.x*CELL+pad, seg.y*CELL+pad, CELL-pad*2, CELL-pad*2, r);
    ctx.fill();

    if (isHead) {
      // Eyes
      ctx.fillStyle = '#050510';
      ctx.shadowBlur = 0;
      const ex = dir.x===0?3:0, ey = dir.y===0?3:0;
      const ox = dir.x!==0 ? (CELL-6)*(dir.x>0?1:0)+3 : CELL/2;
      const oy = dir.y!==0 ? (CELL-6)*(dir.y>0?1:0)+3 : CELL/2;
      if(dir.x!==0) {
        ctx.beginPath();ctx.arc(seg.x*CELL+ox, seg.y*CELL+6, 2, 0, Math.PI*2);ctx.fill();
        ctx.beginPath();ctx.arc(seg.x*CELL+ox, seg.y*CELL+CELL-6, 2, 0, Math.PI*2);ctx.fill();
      } else {
        ctx.beginPath();ctx.arc(seg.x*CELL+6, seg.y*CELL+oy, 2, 0, Math.PI*2);ctx.fill();
        ctx.beginPath();ctx.arc(seg.x*CELL+CELL-6, seg.y*CELL+oy, 2, 0, Math.PI*2);ctx.fill();
      }
    }
  });

  ctx.shadowBlur = 0;
}

function drawFood() {
  const pulse = 0.6 + 0.4*Math.sin(frameCount * 0.12);
  const cx = food.x*CELL+CELL/2, cy = food.y*CELL+CELL/2;
  
  // Glow rings
  ctx.strokeStyle = `rgba(255,0,170,${0.15*pulse})`;
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.arc(cx, cy, 10+pulse*3, 0, Math.PI*2); ctx.stroke();
  
  ctx.shadowColor = COLORS.food;
  ctx.shadowBlur = 15*pulse;
  ctx.fillStyle = COLORS.food;
  ctx.beginPath(); ctx.arc(cx, cy, 5+pulse, 0, Math.PI*2); ctx.fill();
  
  ctx.fillStyle = 'rgba(255,255,255,0.7)';
  ctx.shadowBlur = 0;
  ctx.beginPath(); ctx.arc(cx-1.5, cy-1.5, 1.5, 0, Math.PI*2); ctx.fill();
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.lineTo(x+w-r,y); ctx.arcTo(x+w,y,x+w,y+r,r);
  ctx.lineTo(x+w,y+h-r); ctx.arcTo(x+w,y+h,x+w-r,y+h,r);
  ctx.lineTo(x+r,y+h); ctx.arcTo(x,y+h,x,y+h-r,r);
  ctx.lineTo(x,y+r); ctx.arcTo(x,y,x+r,y,r);
  ctx.closePath();
}

function die() {
  running = false;
  cancelAnimationFrame(gameLoop);
  
  // Flash snake red
  snake.forEach(s => spawnParticles(s.x, s.y, '#ff0044', 4));
  draw();

  setTimeout(() => {
    overlay.innerHTML = `
      <h2 class="dead-title">FLATLINED</h2>
      <p>Score: <strong style="color:var(--neon-green)">${score}</strong> &nbsp;|&nbsp; Level: <strong style="color:var(--neon-blue)">${level}</strong></p>
      <p>Best: <strong style="color:var(--neon-yellow)">${best}</strong></p>
      <button class="btn" id="start-btn">RESTART</button>
    `;
    overlay.style.display = 'flex';
    document.getElementById('start-btn').addEventListener('click', startGame);
  }, 400);
}

function startGame() {
  overlay.style.display = 'none';
  initGame();
  running = true;
  function loop() {
    step();
    if(running) gameLoop = requestAnimationFrame(loop);
  }
  gameLoop = requestAnimationFrame(loop);
}

document.addEventListener('keydown', e => {
  const keys = {
    ArrowUp:{x:0,y:-1}, ArrowDown:{x:0,y:1}, ArrowLeft:{x:-1,y:0}, ArrowRight:{x:1,y:0},
    w:{x:0,y:-1}, s:{x:0,y:1}, a:{x:-1,y:0}, d:{x:1,y:0},
    W:{x:0,y:-1}, S:{x:0,y:1}, A:{x:-1,y:0}, D:{x:1,y:0},
  };
  const newDir = keys[e.key];
  if (newDir) {
    e.preventDefault();
    if (newDir.x !== -dir.x || newDir.y !== -dir.y) nextDir = newDir;
  }
});

startBtn.addEventListener('click', startGame);

// Touch/swipe support
let touchStart = null;
canvas.addEventListener('touchstart', e => { touchStart = {x:e.touches[0].clientX, y:e.touches[0].clientY}; });
canvas.addEventListener('touchend', e => {
  if (!touchStart) return;
  const dx = e.changedTouches[0].clientX - touchStart.x;
  const dy = e.changedTouches[0].clientY - touchStart.y;
  if (Math.abs(dx) > Math.abs(dy)) {
    const nd = dx>0 ? {x:1,y:0} : {x:-1,y:0};
    if (nd.x !== -dir.x) nextDir = nd;
  } else {
    const nd = dy>0 ? {x:0,y:1} : {x:0,y:-1};
    if (nd.y !== -dir.y) nextDir = nd;
  }
  touchStart = null;
});

// Initial draw
initGame();
draw();
</script>
</body>
</html>
