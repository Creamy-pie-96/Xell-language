{
  "$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
  "name": "ScriptIt",
  "scopeName": "source.scriptit",
  "fileTypes": [
    "si",
    "sit"
  ],
  "comment": "AUTO-GENERATED by gen_grammar.py — DO NOT EDIT MANUALLY. Change the parser (scriptit_types.hpp, scriptit_builtins.hpp) and re-run: python3 scripts/gen_grammar.py",
  "patterns": [
    {
      "include": "#block-comment"
    },
    {
      "include": "#line-comment"
    },
    {
      "include": "#strings"
    },
    {
      "include": "#function-definition"
    },
    {
      "include": "#forward-declaration"
    },
    {
      "include": "#var-declaration"
    },
    {
      "include": "#let-declaration"
    },
    {
      "include": "#new-declaration"
    },
    {
      "include": "#for-loop"
    },
    {
      "include": "#for-in-loop"
    },
    {
      "include": "#with-as"
    },
    {
      "include": "#special-keywords"
    },
    {
      "include": "#control-keywords"
    },
    {
      "include": "#loop-keywords"
    },
    {
      "include": "#context-keywords"
    },
    {
      "include": "#logical-operators"
    },
    {
      "include": "#var-keyword"
    },
    {
      "include": "#boolean-constants"
    },
    {
      "include": "#none-constant"
    },
    {
      "include": "#builtin-functions"
    },
    {
      "include": "#math-functions"
    },
    {
      "include": "#type-functions"
    },
    {
      "include": "#edge-operators"
    },
    {
      "include": "#comparison-operators"
    },
    {
      "include": "#compound-assignment"
    },
    {
      "include": "#increment-operators"
    },
    {
      "include": "#assignment-operator"
    },
    {
      "include": "#arithmetic-operators"
    },
    {
      "include": "#logical-symbol-operators"
    },
    {
      "include": "#numbers"
    },
    {
      "include": "#method-call"
    },
    {
      "include": "#function-call"
    },
    {
      "include": "#ref-parameter"
    },
    {
      "include": "#semicolon-terminator"
    },
    {
      "include": "#dot-terminator"
    },
    {
      "include": "#punctuation"
    },
    {
      "include": "#identifiers"
    }
  ],
  "repository": {
    "block-comment": {
      "name": "comment.block.arrow.scriptit",
      "begin": "-->",
      "end": "<--",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.comment.begin.scriptit"
        }
      },
      "endCaptures": {
        "0": {
          "name": "punctuation.definition.comment.end.scriptit"
        }
      }
    },
    "line-comment": {
      "name": "comment.line.number-sign.scriptit",
      "match": "#.*$"
    },
    "strings": {
      "patterns": [
        {
          "name": "string.quoted.double.scriptit",
          "begin": "\"",
          "end": "\"",
          "patterns": [
            {
              "name": "constant.character.escape.scriptit",
              "match": "\\\\."
            }
          ]
        },
        {
          "name": "string.quoted.single.scriptit",
          "begin": "'",
          "end": "'",
          "patterns": [
            {
              "name": "constant.character.escape.scriptit",
              "match": "\\\\."
            }
          ]
        }
      ]
    },
    "function-definition": {
      "comment": "fn name(param1, @param2):  — captures fn, name, each param",
      "patterns": [
        {
          "name": "meta.function.definition.scriptit",
          "begin": "\\b(fn)\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*\\(",
          "beginCaptures": {
            "1": {
              "name": "keyword.declaration.function.scriptit"
            },
            "2": {
              "name": "entity.name.function.definition.scriptit"
            }
          },
          "end": "\\)\\s*(:|\\.)",
          "endCaptures": {
            "1": {
              "name": "punctuation.definition.function.scriptit"
            }
          },
          "patterns": [
            {
              "comment": "Reference parameter with @",
              "match": "(@)([a-zA-Z_][a-zA-Z0-9_]*)",
              "captures": {
                "1": {
                  "name": "storage.modifier.reference.scriptit"
                },
                "2": {
                  "name": "variable.parameter.reference.scriptit"
                }
              }
            },
            {
              "comment": "Regular parameter",
              "name": "variable.parameter.scriptit",
              "match": "\\b([a-zA-Z_][a-zA-Z0-9_]*)\\b"
            },
            {
              "name": "punctuation.separator.parameter.scriptit",
              "match": ","
            }
          ]
        }
      ]
    },
    "forward-declaration": {
      "comment": "fn name(params). — forward declaration ending with dot",
      "patterns": [
        {
          "name": "meta.forward-declaration.scriptit",
          "match": "\\b(fn)\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*\\([^)]*\\)\\s*\\.",
          "captures": {
            "1": {
              "name": "keyword.declaration.function.scriptit"
            },
            "2": {
              "name": "entity.name.function.forward.scriptit"
            }
          }
        }
      ]
    },
    "var-declaration": {
      "comment": "var x = ... OR var x, y, z = ...",
      "patterns": [
        {
          "name": "meta.var.declaration.scriptit",
          "begin": "\\b(var)\\s+",
          "beginCaptures": {
            "1": {
              "name": "storage.type.var.scriptit"
            }
          },
          "end": "(?==)|(?=\\.\\s*$)|(?=\\.\\s*#)|$",
          "patterns": [
            {
              "name": "variable.other.declaration.scriptit",
              "match": "\\b([a-zA-Z_][a-zA-Z0-9_]*)\\b"
            },
            {
              "name": "punctuation.separator.comma.scriptit",
              "match": ","
            }
          ]
        }
      ]
    },
    "let-declaration": {
      "comment": "let x be ...",
      "patterns": [
        {
          "match": "\\b(let)\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s+(be)\\b",
          "captures": {
            "1": {
              "name": "keyword.other.special.scriptit"
            },
            "2": {
              "name": "variable.other.declaration.scriptit"
            },
            "3": {
              "name": "keyword.other.special.scriptit"
            }
          }
        }
      ]
    },
    "new-declaration": {
      "comment": "new x are [...]",
      "patterns": [
        {
          "match": "\\b(new)\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s+(are)\\b",
          "captures": {
            "1": {
              "name": "keyword.other.special.scriptit"
            },
            "2": {
              "name": "variable.other.declaration.scriptit"
            },
            "3": {
              "name": "keyword.other.special.scriptit"
            }
          }
        }
      ]
    },
    "for-loop": {
      "comment": "for i in range(...)",
      "patterns": [
        {
          "match": "\\b(for)\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s+(in)\\s+(range)\\b",
          "captures": {
            "1": {
              "name": "keyword.control.flow.scriptit"
            },
            "2": {
              "name": "variable.other.loop.scriptit"
            },
            "3": {
              "name": "keyword.control.loop.scriptit"
            },
            "4": {
              "name": "keyword.control.loop.scriptit"
            }
          }
        }
      ]
    },
    "for-in-loop": {
      "comment": "for item in collection",
      "patterns": [
        {
          "match": "\\b(for)\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s+(in)\\b",
          "captures": {
            "1": {
              "name": "keyword.control.flow.scriptit"
            },
            "2": {
              "name": "variable.other.loop.scriptit"
            },
            "3": {
              "name": "keyword.control.loop.scriptit"
            }
          }
        }
      ]
    },
    "with-as": {
      "comment": "with open(...) as handle:",
      "patterns": [
        {
          "match": "\\b(with)\\b(.+?)\\b(as)\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*:",
          "captures": {
            "1": {
              "name": "keyword.control.context.scriptit"
            },
            "3": {
              "name": "keyword.control.context.scriptit"
            },
            "4": {
              "name": "variable.other.declaration.scriptit"
            }
          }
        }
      ]
    },
    "special-keywords": {
      "comment": "fn, give, are, be, let, new, of — auto-generated from parser",
      "patterns": [
        {
          "name": "keyword.declaration.function.scriptit",
          "match": "\\b(fn)\\b"
        },
        {
          "name": "keyword.control.return.scriptit",
          "match": "\\b(give)\\b"
        },
        {
          "name": "keyword.other.special.scriptit",
          "match": "\\b(are|let|new|be|of)\\b"
        }
      ]
    },
    "control-keywords": {
      "comment": "Auto-generated: break, case, default, elif, else, for, if, pass, return, switch, while",
      "patterns": [
        {
          "name": "keyword.control.flow.scriptit",
          "match": "\\b(default|return|switch|break|while|case|elif|else|pass|for|if)\\b"
        }
      ]
    },
    "loop-keywords": {
      "comment": "Auto-generated: from, in, range, step, to",
      "patterns": [
        {
          "name": "keyword.control.loop.scriptit",
          "match": "\\b(range|from|step|in|to)\\b"
        }
      ]
    },
    "context-keywords": {
      "comment": "Auto-generated: as, with",
      "patterns": [
        {
          "name": "keyword.control.context.scriptit",
          "match": "\\b(with|as)\\b"
        }
      ]
    },
    "logical-operators": {
      "comment": "Auto-generated: and, is, not, or, points",
      "patterns": [
        {
          "name": "keyword.operator.logical.scriptit",
          "match": "\\b(points|and|not|is|or)\\b"
        }
      ]
    },
    "var-keyword": {
      "comment": "Standalone var keyword",
      "patterns": [
        {
          "name": "storage.type.var.scriptit",
          "match": "\\b(var)\\b"
        }
      ]
    },
    "boolean-constants": {
      "patterns": [
        {
          "name": "constant.language.boolean.true.scriptit",
          "match": "\\bTrue\\b"
        },
        {
          "name": "constant.language.boolean.false.scriptit",
          "match": "\\bFalse\\b"
        }
      ]
    },
    "none-constant": {
      "patterns": [
        {
          "name": "constant.language.none.scriptit",
          "match": "\\bNone\\b"
        }
      ]
    },
    "builtin-functions": {
      "comment": "Auto-generated: 22 builtin functions",
      "patterns": [
        {
          "name": "support.function.builtin.scriptit",
          "match": "\\b(isinstance|enumerate|readLine|reversed|append|pprint|sorted|close|input|print|write|open|read|repr|type|all|any|len|map|pop|sum|zip)\\b(?=\\s*\\()"
        }
      ]
    },
    "math-functions": {
      "comment": "Auto-generated: 22 math functions",
      "patterns": [
        {
          "name": "support.function.math.scriptit",
          "match": "\\b(floor|log10|round|acos|acot|acsc|asec|asin|atan|ceil|log2|sqrt|abs|cos|cot|csc|log|max|min|sec|sin|tan)\\b(?=\\s*\\()"
        }
      ]
    },
    "type-functions": {
      "comment": "Auto-generated: 17 type conversion functions",
      "patterns": [
        {
          "name": "support.type.conversion.scriptit",
          "match": "\\b(auto_numeric|long_double|range_list|ulong_long|long_long|double|float|graph|ulong|bool|dict|list|long|uint|int|set|str)\\b(?=\\s*\\()"
        }
      ]
    },
    "edge-operators": {
      "comment": "Auto-generated edge/arrow operators: ->, <->, ---",
      "patterns": [
        {
          "name": "keyword.operator.edge.scriptit",
          "match": "<->"
        },
        {
          "name": "keyword.operator.edge.scriptit",
          "match": "---"
        },
        {
          "name": "keyword.operator.edge.scriptit",
          "match": "->(?!-)"
        }
      ]
    },
    "comparison-operators": {
      "patterns": [
        {
          "name": "keyword.operator.comparison.scriptit",
          "match": "==|!=|<=|>=|<|>"
        }
      ]
    },
    "compound-assignment": {
      "patterns": [
        {
          "name": "keyword.operator.assignment.compound.scriptit",
          "match": "\\+=|-=|\\*=|/=|%="
        }
      ]
    },
    "increment-operators": {
      "patterns": [
        {
          "name": "keyword.operator.increment.scriptit",
          "match": "\\+\\+|--"
        }
      ]
    },
    "assignment-operator": {
      "patterns": [
        {
          "name": "keyword.operator.assignment.scriptit",
          "match": "="
        }
      ]
    },
    "arithmetic-operators": {
      "patterns": [
        {
          "name": "keyword.operator.arithmetic.scriptit",
          "match": "\\+|-|\\*|/|%|\\^"
        }
      ]
    },
    "logical-symbol-operators": {
      "patterns": [
        {
          "name": "keyword.operator.logical.symbol.scriptit",
          "match": "&&|\\|\\|"
        }
      ]
    },
    "numbers": {
      "patterns": [
        {
          "name": "constant.numeric.float.scriptit",
          "match": "(?<![a-zA-Z_\\.])\\d+\\.\\d+"
        },
        {
          "name": "constant.numeric.integer.scriptit",
          "match": "(?<![a-zA-Z_\\.])\\d+(?!\\.\\d)"
        }
      ]
    },
    "method-call": {
      "comment": ".name( — method call",
      "patterns": [
        {
          "match": "\\.([a-zA-Z_][a-zA-Z0-9_]*)\\s*(?=\\()",
          "captures": {
            "1": {
              "name": "entity.name.function.method.scriptit"
            }
          }
        }
      ]
    },
    "function-call": {
      "comment": "name( — function call",
      "patterns": [
        {
          "match": "\\b([a-zA-Z_][a-zA-Z0-9_]*)\\s*(?=\\()",
          "captures": {
            "1": {
              "name": "entity.name.function.call.scriptit"
            }
          }
        }
      ]
    },
    "ref-parameter": {
      "comment": "@variable — pass-by-reference",
      "patterns": [
        {
          "match": "(@)([a-zA-Z_][a-zA-Z0-9_]*)",
          "captures": {
            "1": {
              "name": "storage.modifier.reference.scriptit"
            },
            "2": {
              "name": "variable.other.reference.scriptit"
            }
          }
        }
      ]
    },
    "semicolon-terminator": {
      "patterns": [
        {
          "name": "punctuation.terminator.block.scriptit",
          "match": "^\\s*;\\s*$"
        }
      ]
    },
    "dot-terminator": {
      "patterns": [
        {
          "name": "punctuation.terminator.statement.scriptit",
          "match": "\\.(?=\\s*$|\\s*#)"
        }
      ]
    },
    "punctuation": {
      "patterns": [
        {
          "name": "punctuation.bracket.round.scriptit",
          "match": "[()]"
        },
        {
          "name": "punctuation.bracket.square.scriptit",
          "match": "[\\[\\]]"
        },
        {
          "name": "punctuation.bracket.curly.scriptit",
          "match": "[{}]"
        },
        {
          "name": "punctuation.separator.comma.scriptit",
          "match": ","
        },
        {
          "name": "punctuation.separator.colon.scriptit",
          "match": ":"
        }
      ]
    },
    "identifiers": {
      "comment": "Catch-all: remaining identifiers → variable color",
      "patterns": [
        {
          "name": "variable.other.scriptit",
          "match": "\\b[a-zA-Z_][a-zA-Z0-9_]*\\b"
        }
      ]
    }
  }
}
