Start testing: Mar 02 14:41 +06
----------------------------------------------------------
1/8 Testing: parser_test
1/8 Test: parser_test
Command: "/home/DATA/CODE/code/Xell/build/parser_test"
Directory: /home/DATA/CODE/code/Xell/build
"parser_test" start time: Mar 02 14:41 +06
Output:
----------------------------------------------------------

===== Xell Lexer Tests =====
  [32mPASS[0m: lexer: simple tokens
  [32mPASS[0m: lexer: all keywords
  [32mPASS[0m: lexer: all operators
  [32mPASS[0m: lexer: string with interpolation
  [32mPASS[0m: lexer: numbers
  [32mPASS[0m: lexer: newlines collapsed
  [32mPASS[0m: lexer: single-line comment
  [32mPASS[0m: lexer: multi-line comment
  [32mPASS[0m: lexer: arrow vs comment
  [32mPASS[0m: lexer: newlines in brackets
  [32mPASS[0m: lexer: ! standalone
  [32mPASS[0m: lexer: ++ token
  [32mPASS[0m: lexer: -- token
  [32mPASS[0m: lexer: -- vs --> comment
  [32mPASS[0m: lexer: escape sequences

===== Parser: Literals =====
  [32mPASS[0m: parse: number literal
  [32mPASS[0m: parse: float literal
  [32mPASS[0m: parse: string literal
  [32mPASS[0m: parse: bool true
  [32mPASS[0m: parse: bool false
  [32mPASS[0m: parse: none literal
  [32mPASS[0m: parse: identifier

===== Parser: Assignment =====
  [32mPASS[0m: parse: simple assignment
  [32mPASS[0m: parse: string assignment
  [32mPASS[0m: parse: bool assignment
  [32mPASS[0m: parse: expression assignment

===== Parser: Arithmetic =====
  [32mPASS[0m: parse: addition
  [32mPASS[0m: parse: operator precedence
  [32mPASS[0m: parse: grouped expression
  [32mPASS[0m: parse: subtraction and division
  [32mPASS[0m: parse: unary 'not' keyword
  [32mPASS[0m: parse: unary '!' operator
  [32mPASS[0m: parse: unary minus

===== Parser: Increment / Decrement =====
  [32mPASS[0m: parse: prefix ++
  [32mPASS[0m: parse: prefix --
  [32mPASS[0m: parse: postfix ++
  [32mPASS[0m: parse: postfix --
  [32mPASS[0m: parse: ++ inside while loop

===== Parser: Comparison & Logical =====
  [32mPASS[0m: parse: ==
  [32mPASS[0m: parse: 'is' keyword
  [32mPASS[0m: parse: 'eq' keyword
  [32mPASS[0m: parse: 'ne' keyword
  [32mPASS[0m: parse: 'gt' keyword
  [32mPASS[0m: parse: 'lt' keyword
  [32mPASS[0m: parse: 'ge' keyword
  [32mPASS[0m: parse: 'le' keyword
  [32mPASS[0m: parse: 'and'
  [32mPASS[0m: parse: 'or'
  [32mPASS[0m: parse: complex logical precedence
  [32mPASS[0m: parse: ! in if condition

===== Parser: Lists & Maps =====
  [32mPASS[0m: parse: list literal
  [32mPASS[0m: parse: empty list
  [32mPASS[0m: parse: nested list
  [32mPASS[0m: parse: map literal
  [32mPASS[0m: parse: empty map
  [32mPASS[0m: parse: multiline map
  [32mPASS[0m: parse: mixed list types

===== Parser: Function Calls =====
  [32mPASS[0m: parse: call no args
  [32mPASS[0m: parse: call with args
  [32mPASS[0m: parse: call with expression args
  [32mPASS[0m: parse: paren-less call single arg
  [32mPASS[0m: parse: paren-less call multi args
  [32mPASS[0m: parse: paren-less call identifier
  [32mPASS[0m: parse: nested call
  [32mPASS[0m: parse: call result assignment

===== Parser: Access =====
  [32mPASS[0m: parse: index access
  [32mPASS[0m: parse: member access ->
  [32mPASS[0m: parse: chained ->[]
  [32mPASS[0m: parse: string index access

===== Parser: Control Flow =====
  [32mPASS[0m: parse: simple if
  [32mPASS[0m: parse: if/else
  [32mPASS[0m: parse: if/elif/else
  [32mPASS[0m: parse: if with logical

===== Parser: Loops =====
  [32mPASS[0m: parse: for loop
  [32mPASS[0m: parse: for with call iterable
  [32mPASS[0m: parse: while loop

===== Parser: Functions =====
  [32mPASS[0m: parse: fn def no params
  [32mPASS[0m: parse: fn def with params
  [32mPASS[0m: parse: fn def with give
  [32mPASS[0m: parse: fn def give no value

===== Parser: Bring =====
  [32mPASS[0m: parse: bring all
  [32mPASS[0m: parse: bring named
  [32mPASS[0m: parse: bring with aliases

===== Parser: Complex =====
  [32mPASS[0m: parse: multiple statements
  [32mPASS[0m: parse: dot-terminated statements
  [32mPASS[0m: parse: nested if/for
  [32mPASS[0m: parse: comments ignored
  [32mPASS[0m: parse: string interpolation
  [32mPASS[0m: parse: full program

============================================
  Total: 89  |  [32mPassed: 89[0m  |  [31mFailed: 0[0m
============================================

<end of output>
Test time =   0.00 sec
----------------------------------------------------------
Test Passed.
"parser_test" end time: Mar 02 14:41 +06
"parser_test" time elapsed: 00:00:00
----------------------------------------------------------

2/8 Testing: error_test
2/8 Test: error_test
Command: "/home/DATA/CODE/code/Xell/build/error_test"
Directory: /home/DATA/CODE/code/Xell/build
"error_test" start time: Mar 02 14:41 +06
Output:
----------------------------------------------------------

===== Error Construction & Metadata =====
  PASS: XellError: construction
  PASS: LexerError: construction
  PASS: ParseError: construction
  PASS: TypeError: construction
  PASS: UndefinedVariableError: construction
  PASS: UndefinedFunctionError: construction
  PASS: IndexError: construction
  PASS: KeyError: construction
  PASS: DivisionByZeroError: construction
  PASS: OverflowError: construction
  PASS: ArityError: construction
  PASS: BringError: construction
  PASS: FileNotFoundError: construction
  PASS: IOError: construction
  PASS: ProcessError: construction
  PASS: ConversionError: construction
  PASS: EnvError: construction
  PASS: RecursionError: construction
  PASS: AssertionError: construction
  PASS: NotImplementedError: construction

===== Catch Hierarchy =====
  PASS: LexerError caught as LexerError
  PASS: LexerError caught as XellError
  PASS: LexerError caught as std::runtime_error
  PASS: ParseError caught as ParseError
  PASS: ParseError caught as XellError
  PASS: TypeError caught as XellError
  PASS: UndefinedVariableError caught as XellError
  PASS: UndefinedFunctionError caught as XellError
  PASS: IndexError caught as XellError
  PASS: KeyError caught as XellError
  PASS: DivisionByZeroError caught as XellError
  PASS: ArityError caught as XellError
  PASS: BringError caught as XellError
  PASS: FileNotFoundError caught as XellError
  PASS: IOError caught as XellError
  PASS: ProcessError caught as XellError
  PASS: ConversionError caught as XellError
  PASS: EnvError caught as XellError
  PASS: RecursionError caught as XellError
  PASS: AssertionError caught as XellError
  PASS: NotImplementedError caught as XellError
  PASS: OverflowError caught as XellError

===== Lexer Error Integration =====
  PASS: lexer: unterminated string â†’ LexerError
  PASS: lexer: unterminated string on line 3 â†’ correct line
  PASS: lexer: unexpected character â†’ LexerError
  PASS: lexer: unexpected character $ â†’ LexerError
  PASS: lexer: unexpected character ~ â†’ LexerError
  PASS: lexer: LexerError is also catchable as XellError

===== Parser Error Integration =====
  PASS: parser: missing ':' after if â†’ ParseError
  PASS: parser: missing ';' to close if â†’ ParseError
  PASS: parser: missing ')' after args â†’ ParseError
  PASS: parser: missing ']' after list â†’ ParseError
  PASS: parser: missing '}' after map â†’ ParseError
  PASS: parser: missing '(' after fn name â†’ ParseError
  PASS: parser: missing 'from' in bring â†’ ParseError
  PASS: parser: unexpected token â†’ ParseError
  PASS: parser: missing ':' after while â†’ ParseError
  PASS: parser: missing 'in' in for â†’ ParseError
  PASS: parser: ParseError is also catchable as XellError
  PASS: parser: ParseError carries correct line number

===== Error Specificity =====
  PASS: specific catch before generic: LexerError vs XellError
  PASS: specific catch before generic: ParseError vs XellError
  PASS: specific catch before generic: TypeError vs XellError
  PASS: specific catch before generic: IndexError vs XellError
  PASS: generic XellError catches all derived errors

===== Message Format =====
  PASS: all errors follow [XELL ERROR] Line N format
  PASS: what() contains category and detail

============================================
  Total: 67  |  Passed: 67  |  Failed: 0
============================================
<end of output>
Test time =   0.00 sec
----------------------------------------------------------
Test Passed.
"error_test" end time: Mar 02 14:41 +06
"error_test" time elapsed: 00:00:00
----------------------------------------------------------

3/8 Testing: xobject_test
3/8 Test: xobject_test
Command: "/home/DATA/CODE/code/Xell/build/xobject_test"
Directory: /home/DATA/CODE/code/Xell/build
"xobject_test" start time: Mar 02 14:41 +06
Output:
----------------------------------------------------------

===== XObject Construction =====
  PASS: none: default constructor
  PASS: none: makeNone
  PASS: number: integer
  PASS: number: float
  PASS: number: zero
  PASS: number: negative
  PASS: bool: true
  PASS: bool: false
  PASS: string: lvalue
  PASS: string: rvalue
  PASS: string: empty
  PASS: list: empty
  PASS: list: with elements
  PASS: map: empty
  PASS: map: with entries
  PASS: function
  PASS: xtype_name strings

===== Reference Counting =====
  PASS: initial ref count is 1
  PASS: copy increments ref count
  PASS: copy assignment increments ref count
  PASS: move leaves source null (no leak)
  PASS: move assignment
  PASS: ref count drops to zero â†’ freed
  PASS: many copies then destroy
  PASS: self-assignment is safe
  PASS: re-assign releases old value

===== Truthiness =====
  PASS: none is falsy
  PASS: false is falsy
  PASS: true is truthy
  PASS: 0 is falsy
  PASS: non-zero number is truthy
  PASS: negative number is truthy
  PASS: empty string is falsy
  PASS: non-empty string is truthy
  PASS: empty list is falsy
  PASS: non-empty list is truthy
  PASS: empty map is falsy
  PASS: non-empty map is truthy
  PASS: function is always truthy

===== toString =====
  PASS: none â†’ "none"
  PASS: integer number â†’ no decimal
  PASS: zero â†’ "0"
  PASS: negative integer â†’ "-5"
  PASS: float number â†’ has decimal
  PASS: bool true â†’ "true"
  PASS: bool false â†’ "false"
  PASS: string â†’ itself
  PASS: empty list â†’ "[]"
  PASS: list of numbers â†’ "[1, 2, 3]"
  PASS: list with strings â†’ quoted strings
  PASS: empty map â†’ "{}"
  PASS: map â†’ key: value format
  PASS: function â†’ "<fn name>"

===== Equality =====
  PASS: none == none
  PASS: number == same number
  PASS: number != different number
  PASS: bool == same bool
  PASS: bool != different bool
  PASS: string == same string
  PASS: string != different string
  PASS: different types are never equal
  PASS: same XData pointer â†’ equal
  PASS: list == same elements
  PASS: list != different elements
  PASS: list != different size
  PASS: map == same entries
  PASS: map != different values
  PASS: map != different keys
  PASS: function equality is identity

===== Deep Clone =====
  PASS: clone none
  PASS: clone number is independent
  PASS: clone string is independent
  PASS: clone list is deep
  PASS: clone map is deep
  PASS: clone preserves equality

===== XMap =====
  PASS: map: set and get
  PASS: map: overwrite existing key
  PASS: map: preserves insertion order
  PASS: map: const get

===== Mutable Access =====
  PASS: asStringMut: modify in place
  PASS: asListMut: push_back
  PASS: asMapMut: add entries

===== Edge Cases =====
  PASS: nested list of lists
  PASS: map containing list
  PASS: list containing map
  PASS: shared list: copy shares data, clone is independent
  PASS: large number of allocations and frees
  PASS: rapid create-destroy cycle (no leak)
  PASS: moved-from XObject is safe to destroy
  PASS: moved-from XObject is none-like

===== Leak Detection =====
  PASS: liveAllocations starts at 0 after reset
  PASS: liveAllocations tracks correctly

============================================
  Total: 92  |  Passed: 92  |  Failed: 0
============================================
<end of output>
Test time =   0.01 sec
----------------------------------------------------------
Test Passed.
"xobject_test" end time: Mar 02 14:41 +06
"xobject_test" time elapsed: 00:00:00
----------------------------------------------------------

4/8 Testing: interpreter_test
4/8 Test: interpreter_test
Command: "/home/DATA/CODE/code/Xell/build/interpreter_test"
Directory: /home/DATA/CODE/code/Xell/build
"interpreter_test" start time: Mar 02 14:41 +06
Output:
----------------------------------------------------------

===== Basic Expressions & Print =====
  PASS: print number
  PASS: print string
  PASS: print bool true
  PASS: print bool false
  PASS: print none
  PASS: print multiple args
  PASS: arithmetic: add
  PASS: arithmetic: subtract
  PASS: arithmetic: multiply
  PASS: arithmetic: divide
  PASS: arithmetic: complex expression
  PASS: arithmetic: parenthesized
  PASS: unary minus
  PASS: string concatenation with +
  PASS: string + number auto-converts
  PASS: list concatenation
  PASS: comparison: ==
  PASS: comparison: !=
  PASS: comparison: > < >= <=
  PASS: logical: and
  PASS: logical: or
  PASS: logical: not
  PASS: short-circuit and: returns last truthy or first falsy
  PASS: short-circuit or: returns first truthy
  PASS: paren-less print call

===== Variables & Assignment =====
  PASS: simple assignment and read
  PASS: re-assignment
  PASS: multiple variables
  PASS: variable in expression
  PASS: assign expression result
  PASS: prefix increment
  PASS: postfix increment
  PASS: prefix decrement
  PASS: postfix decrement

===== Conditionals =====
  PASS: if true
  PASS: if false â€” no output
  PASS: if-else: takes else branch
  PASS: if-elif-else
  PASS: if with comparison expression
  PASS: nested if
  PASS: if: truthiness of number
  PASS: if: truthiness of string
  PASS: multiple elif branches

===== For Loops =====
  PASS: for over list literal
  PASS: for over range
  PASS: for over range(start, end)
  PASS: for with accumulator
  PASS: for over variable list
  PASS: nested for loops
  PASS: for over empty list

===== While Loops =====
  PASS: while countdown
  PASS: while false â€” never executes
  PASS: while with accumulator

===== Functions =====
  PASS: simple function definition and call
  PASS: function with parameter
  PASS: function with give (return)
  PASS: function returns none by default
  PASS: function with multiple params
  PASS: function calling another function
  PASS: early give (return)
  PASS: give with no value â†’ none

===== Scoping =====
  PASS: global variable accessible in function
  PASS: function can modify global variable
  PASS: function local does not leak
  PASS: if-block scope does not leak
  PASS: for-block scope does not leak
  PASS: while-block scope does not leak
  PASS: nested function scope
  PASS: parameter shadows global

===== Recursion =====
  PASS: factorial
  PASS: fibonacci
  PASS: recursion depth limit

===== Lists =====
  PASS: list literal
  PASS: empty list
  PASS: list index access
  PASS: list negative index
  PASS: len of list
  PASS: push and pop
  PASS: set list element
  PASS: list index out of bounds

===== Maps =====
  PASS: map literal
  PASS: map index access with string key
  PASS: map arrow access
  PASS: keys and values
  PASS: has() builtin
  PASS: set map entry
  PASS: map key not found

===== String Operations =====
  PASS: string length
  PASS: string index
  PASS: string negative index
  PASS: string concatenation

===== Built-in Functions =====
  PASS: type()
  PASS: str() conversion
  PASS: num() conversion
  PASS: assert passes
  PASS: assert fails
  PASS: assert with message
  PASS: range with step
  PASS: range reverse

===== Error Handling =====
  PASS: undefined variable
  PASS: type error: subtract strings
  PASS: division by zero
  PASS: arity error: too few args
  PASS: arity error: too many args
  PASS: type error: call non-function
  PASS: index error: string out of range
  PASS: type error: for non-list
  PASS: conversion error: bad num()

===== Complex Programs =====
  PASS: FizzBuzz
  PASS: build a list with function
  PASS: counter with while
  PASS: function as value: pass to variable, call later
  PASS: map as config object
  PASS: recursive sum of list
  PASS: higher-order: map function over list
  PASS: power function

===== String Interpolation =====
  PASS: simple variable interpolation
  PASS: expression interpolation
  PASS: multiple interpolations
  PASS: no interpolation when no braces

===== Break & Continue =====
  PASS: break in for loop
  PASS: break in while loop
  PASS: continue in for loop
  PASS: continue in while loop
  PASS: break only exits innermost loop
  PASS: continue only affects innermost loop
  PASS: break with accumulator
  PASS: continue skips even numbers
  PASS: break and continue together
  PASS: while break with found flag

===== Try / Catch / Finally =====
  PASS: try-catch catches error
  PASS: try-catch error message
  PASS: try-catch-finally
  PASS: try no error
  PASS: try-finally no error

===== Ternary Operator =====
  PASS: ternary true
  PASS: ternary false
  PASS: ternary with expression
  PASS: ternary with numbers

===== Default Parameters =====
  PASS: default param used
  PASS: default param overridden
  PASS: mixed default and required

===== Variadic Functions =====
  PASS: variadic basic
  PASS: variadic with required params
  PASS: variadic empty

===== Lambda / Arrow Functions =====
  PASS: single param lambda
  PASS: multi param lambda
  PASS: lambda closure
  PASS: lambda as parameter
  PASS: zero param lambda

===== Augmented Assignment =====
  PASS: plus equal
  PASS: minus equal
  PASS: star equal
  PASS: slash equal
  PASS: percent equal
  PASS: string plus equal

===== Destructuring =====
  PASS: basic destructuring
  PASS: destructuring three values
  PASS: destructuring fewer values

===== Spread Operator =====
  PASS: spread in list literal
  PASS: spread in function call

===== InCase (Switch) =====
  PASS: incase basic match
  PASS: incase with else
  PASS: incase with or
  PASS: incase string match

===== Multi-line & Raw Strings =====
  PASS: multi-line string
  PASS: raw string no escape

===== format() Builtin =====
  PASS: format basic
  PASS: format multiple args
  PASS: format indexed
  PASS: format float precision

===== typeof Builtin =====
  PASS: typeof number
  PASS: typeof string
  PASS: typeof list

===== input() / exit() =====
  PASS: exit is callable (verified by no crash)

===== Chained Comparison =====
  PASS: simple comparison
  PASS: chained less than

===== Int / Float Distinction =====
  PASS: int literal type
  PASS: float literal type
  PASS: int + int = int
  PASS: int + float = float
  PASS: int * int = int
  PASS: int / int exact = int
  PASS: int / int inexact = float
  PASS: int % int = int
  PASS: int - int = int
  PASS: unary minus int = int
  PASS: prefix ++ on int stays int
  PASS: postfix ++ on int stays int
  PASS: int() conversion
  PASS: float() conversion
  PASS: cross-type equality int == float
  PASS: range returns ints
  PASS: len returns int
  PASS: floor/ceil/round return int

===== Complex Numbers =====
  PASS: imaginary literal type
  PASS: complex from addition
  PASS: complex from subtraction
  PASS: pure imaginary
  PASS: complex + complex
  PASS: complex - complex
  PASS: complex * complex
  PASS: complex / complex
  PASS: complex + int
  PASS: int + complex
  PASS: unary minus complex
  PASS: complex equality
  PASS: complex inequality
  PASS: complex() builtin
  PASS: real() and imag()
  PASS: conjugate()
  PASS: magnitude()
  PASS: complex is hashable
  PASS: complex truthy
  PASS: sqrt of negative = complex

===== Frozen Sets =====
  PASS: frozen set literal
  PASS: empty frozen set
  PASS: frozen set len
  PASS: frozen set has
  PASS: frozen set contains
  PASS: frozen set is immutable (add)
  PASS: frozen set is immutable (remove)
  PASS: frozen set equality
  PASS: frozen set is hashable
  PASS: frozen set in map key (hashable)
  PASS: frozen set to_list
  PASS: frozen set to_tuple
  PASS: frozen set to_set
  PASS: frozen set with mixed types
  PASS: frozen set deduplication
  PASS: union_set with frozen_set
  PASS: intersect with frozen_set
  PASS: diff with frozen_set

===== Hash Enhancements =====
  PASS: hash int
  PASS: hash float
  PASS: hash string
  PASS: hash complex
  PASS: hash frozen_set
  PASS: hash tuple
  PASS: hash with algorithm
  PASS: hash_seed
  PASS: hash_seed complex
  PASS: hash_seed frozen_set

============================================
  Total: 243  |  Passed: 243  |  Failed: 0
============================================
<end of output>
Test time =   0.05 sec
----------------------------------------------------------
Test Passed.
"interpreter_test" end time: Mar 02 14:41 +06
"interpreter_test" time elapsed: 00:00:00
----------------------------------------------------------

5/8 Testing: os_test
5/8 Test: os_test
Command: "/home/DATA/CODE/code/Xell/build/os_test"
Directory: /home/DATA/CODE/code/Xell/build
"os_test" start time: Mar 02 14:41 +06
Output:
----------------------------------------------------------
============================================
  Xell OS Abstraction Layer Tests
============================================

--- Section 1: Filesystem â€” Directories ---
  PASS: make_dir creates single dir
  PASS: make_dir creates nested dirs
  PASS: make_dir is no-op if already exists
  PASS: remove_path removes empty dir
  PASS: remove_path removes dir recursively
  PASS: remove_path throws on non-existent
  PASS: list_dir lists children names
  PASS: list_dir_full lists full paths
  PASS: list_dir throws on non-existent
  PASS: list_dir throws on file

--- Section 2: Filesystem â€” Files ---
  PASS: write_file + read_file roundtrip
  PASS: write_file creates parent dirs
  PASS: write_file overwrites existing
  PASS: append_file appends to existing
  PASS: append_file creates new file
  PASS: read_file throws on non-existent
  PASS: read_file throws on directory
  PASS: file_size returns correct size
  PASS: file_size throws on non-existent
  PASS: is_file returns true for file
  PASS: is_dir returns true for directory
  PASS: path_exists returns false for non-existent

--- Section 3: Filesystem â€” Copy/Move/Paths ---
  PASS: copy_path copies a file
  PASS: copy_path copies a directory recursively
  PASS: copy_path throws on non-existent source
  PASS: move_path moves a file
  PASS: move_path throws on non-existent source
  PASS: absolute_path returns absolute
  PASS: file_name extracts filename
  PASS: parent_path extracts parent
  PASS: extension extracts extension
  PASS: cwd returns non-empty
  PASS: change_dir + cwd round-trip
  PASS: change_dir throws on non-existent
  PASS: change_dir throws on file

--- Section 4: Environment Variables ---
  PASS: env_get returns empty for unset var
  PASS: env_has returns false for unset var
  PASS: env_set + env_get round-trip
  PASS: env_has returns true after set
  PASS: env_set overwrites existing
  PASS: env_unset removes variable
  PASS: env_get reads system PATH

--- Section 5: Process Execution ---
  PASS: run returns 0 for successful command
  PASS: run returns non-zero for failing command
  PASS: run executes complex command
  PASS: run_capture captures stdout
  PASS: run_capture captures multi-line stdout
  PASS: run_capture captures stderr
  PASS: run_capture returns exit code from failed command
  PASS: run_capture with command that produces no output
  PASS: run_capture works with pipes
  PASS: run with file creation side effect
  PASS: run_capture with env var
  PASS: get_pid returns positive number

--- Section 6: Edge Cases ---
  PASS: write + read empty file
  PASS: write + read file with special chars
  PASS: write + read binary-ish content
  PASS: list_dir on empty directory
  PASS: file_name of root-like path
  PASS: extension of dotfile
  PASS: make_dir with trailing slash

============================================
  Total: 61  |  Passed: 61  |  Failed: 0
============================================
<end of output>
Test time =   0.02 sec
----------------------------------------------------------
Test Passed.
"os_test" end time: Mar 02 14:41 +06
"os_test" time elapsed: 00:00:00
----------------------------------------------------------

6/8 Testing: bring_test
6/8 Test: bring_test
Command: "/home/DATA/CODE/code/Xell/build/bring_test"
Directory: /home/DATA/CODE/code/Xell/build
"bring_test" start time: Mar 02 14:41 +06
Output:
----------------------------------------------------------
============================================
  Bring (Import) System Tests
============================================

===== Bring: Named Imports =====
  PASS: bring single function
  PASS: bring single variable
  PASS: bring multiple names
  PASS: bring mixed functions and variables
  PASS: bring from math_utils

===== Bring: Aliases =====
  PASS: bring with single alias
  PASS: bring with multiple aliases
  PASS: bring variable with alias
  PASS: partial aliases (fewer aliases than names)

===== Bring: Wildcard (*) =====
  PASS: bring * imports all names
  PASS: bring * from math_utils

===== Bring: Nested Paths =====
  PASS: bring from subdirectory
  PASS: bring * from subdirectory

===== Bring: Usage Patterns =====
  PASS: use brought function in expression
  PASS: brought function as argument to another
  PASS: bring into function scope
  PASS: multiple bring statements
  PASS: bring does not leak unimported names

===== Bring: Error Cases =====
  PASS: bring from nonexistent file
  PASS: bring nonexistent name
  PASS: circular import detection

============================================
  Total: 21  |  Passed: 21  |  Failed: 0
============================================
<end of output>
Test time =   0.02 sec
----------------------------------------------------------
Test Passed.
"bring_test" end time: Mar 02 14:41 +06
"bring_test" time elapsed: 00:00:00
----------------------------------------------------------

7/8 Testing: shell_test
7/8 Test: shell_test
Command: "/home/DATA/CODE/code/Xell/build/shell_test"
Directory: /home/DATA/CODE/code/Xell/build
"shell_test" start time: Mar 02 14:41 +06
Output:
----------------------------------------------------------
done
recovered
yes
recovered
done
final
hello
done
============================================
  Shell Chaining Tests
============================================
  PASS: pipe: basic string concat
  PASS: pipe: multi-stage chain
  PASS: pipe: with variables
  PASS: pipe: type error on non-strings
  PASS: pipe: build and run_capture
  PASS: &&: success runs right
  PASS: &&: failure skips right
  PASS: &&: with numbers (0=success)
  PASS: &&: with non-zero (fail)
  PASS: &&: short-circuit on failure
  PASS: ||: success skips right
  PASS: ||: failure runs right
  PASS: ||: with numbers (0=success)
  PASS: ||: with non-zero (fail)
  PASS: ||: short-circuit on success
  PASS: &&/||: and-then-or chain
  PASS: &&/||: or-then-and chain
  PASS: grouping: (a && b) || c
  PASS: grouping: (a || b) && c
  PASS: grouping: nested ((a && b) || c) && d
  PASS: exit_code: after success
  PASS: exit_code: after failure
  PASS: set_e: stops on failure
  PASS: set_e: allows success
  PASS: unset_e: resumes normal
  PASS: set_e: with run_capture
  PASS: exit_code: updates on each run
  PASS: pipe+run: build and execute pipeline
  PASS: pipe+&&: pipeline then chain
  PASS: shell && vs logical and
  PASS: shell || vs logical or
  PASS: &&: with run_capture map
  PASS: ||: with run_capture map
  PASS: precedence: | higher than &&
  PASS: precedence: && higher than ||
  PASS: precedence: logical and/or still work
  PASS: lexer: | token
  PASS: lexer: && token
  PASS: lexer: || token
  PASS: lexer: single & is error

============================================
  Total: 40  |  Passed: 40  |  Failed: 0
============================================
<end of output>
Test time =   0.05 sec
----------------------------------------------------------
Test Passed.
"shell_test" end time: Mar 02 14:41 +06
"shell_test" time elapsed: 00:00:00
----------------------------------------------------------

8/8 Testing: builtin_test
8/8 Test: builtin_test
Command: "/home/DATA/CODE/code/Xell/build/builtin_test"
Directory: /home/DATA/CODE/code/Xell/build
"builtin_test" start time: Mar 02 14:41 +06
Output:
----------------------------------------------------------
=======================================
   Xell Builtin Tests
=======================================

===== String Builtins =====
  PASS: split basic
  PASS: split with space
  PASS: join basic
  PASS: join empty separator
  PASS: trim whitespace
  PASS: trim_start
  PASS: trim_end
  PASS: upper
  PASS: lower
  PASS: replace all
  PASS: replace_first
  PASS: starts_with true
  PASS: starts_with false
  PASS: ends_with true
  PASS: ends_with false
  PASS: index_of string found
  PASS: index_of string not found
  PASS: index_of list found
  PASS: index_of list not found
  PASS: substr
  PASS: char_at
  PASS: repeat
  PASS: pad_start
  PASS: pad_end
  PASS: reverse string
  PASS: reverse list
  PASS: count string
  PASS: count list
  PASS: is_empty empty string
  PASS: is_empty non-empty string
  PASS: is_empty empty list
  PASS: is_empty non-empty list
  PASS: is_numeric true
  PASS: is_numeric false
  PASS: is_alpha true
  PASS: is_alpha false
  PASS: lines
  PASS: to_chars

===== List Builtins =====
  PASS: shift removes first
  PASS: unshift adds to front
  PASS: insert at index
  PASS: remove_val
  PASS: sort ascending
  PASS: sort_desc descending
  PASS: slice
  PASS: flatten nested
  PASS: unique
  PASS: first
  PASS: last
  PASS: zip two lists
  PASS: sum
  PASS: min of list
  PASS: max of list
  PASS: min of two
  PASS: max of two
  PASS: avg
  PASS: size of list
  PASS: size of string

===== Map Builtins =====
  PASS: delete_key
  PASS: get existing key
  PASS: get missing key returns default
  PASS: merge two maps
  PASS: entries
  PASS: from_entries

===== Math Builtins (Basic) =====
  PASS: log(1) == 0
  PASS: log10(100) == 2
  PASS: clamp within range
  PASS: clamp below low
  PASS: clamp above high
  PASS: is_nan false
  PASS: is_inf false
  PASS: to_int from float
  PASS: to_int from string
  PASS: to_float from int
  PASS: hex
  PASS: bin
  PASS: random returns number
  PASS: random_int in range
  PASS: PI is defined
  PASS: E is defined

===== Math Builtins (Trigonometric) =====
  PASS: sin(0) == 0
  PASS: cos(0) == 1
  PASS: tan(0) == 0
  PASS: sin(PI/2) approx 1
  PASS: cos(PI) approx -1
  PASS: cot(PI/4) approx 1
  PASS: sec(0) == 1
  PASS: csc(PI/2) approx 1
  PASS: asin(0) == 0
  PASS: acos(1) == 0
  PASS: atan(0) == 0
  PASS: atan2(0, 1) == 0
  PASS: atan2(1, 0) approx PI/2
  PASS: asin(1) approx PI/2
  PASS: acot(1) approx PI/4
  PASS: asec(1) == 0
  PASS: acsc(1) approx PI/2
  PASS: asin domain error
  PASS: acos domain error
  PASS: asec domain error |x| < 1
  PASS: acsc domain error |x| < 1

===== Math Builtins (Hyperbolic) =====
  PASS: sinh(0) == 0
  PASS: cosh(0) == 1
  PASS: tanh(0) == 0
  PASS: sinh(1) approx 1.1752
  PASS: cosh(1) approx 1.5431
  PASS: tanh(1) approx 0.7616
  PASS: coth(1) approx 1.3130
  PASS: sech(0) == 1
  PASS: csch(1) approx 0.8509
  PASS: csch(0) division by zero
  PASS: coth(0) division by zero
  PASS: asinh(0) == 0
  PASS: acosh(1) == 0
  PASS: atanh(0) == 0
  PASS: asinh(1) approx 0.8814
  PASS: acosh(2) approx 1.3170
  PASS: acoth(2) approx 0.5493
  PASS: asech(0.5) approx 1.3170
  PASS: acsch(1) approx 0.8814
  PASS: acosh domain error x < 1
  PASS: atanh domain error x == 1
  PASS: acoth domain error |x| <= 1
  PASS: asech domain error x > 1
  PASS: acsch domain error x == 0

===== Higher-Order Function Builtins =====
  PASS: map with lambda
  PASS: map with named fn
  PASS: filter with lambda
  PASS: filter even numbers
  PASS: reduce sum
  PASS: reduce product
  PASS: any true
  PASS: any false
  PASS: all true
  PASS: all false

===== Contains Polymorphic =====
  PASS: contains in string
  PASS: contains not in string
  PASS: contains in list
  PASS: contains not in list

=======================================
  Results: 139 passed, 0 failed
=======================================
<end of output>
Test time =   0.02 sec
----------------------------------------------------------
Test Passed.
"builtin_test" end time: Mar 02 14:41 +06
"builtin_test" time elapsed: 00:00:00
----------------------------------------------------------

End testing: Mar 02 14:41 +06
